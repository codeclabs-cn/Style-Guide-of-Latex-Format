%! Author = codeclabs-cn
%! Date = 2022/12/30

\section{Windows Code}\label{sec:windows-code}
Windows programmers have developed their own set of coding conventions, mainly derived from the conventions in Windows headers and other Microsoft code. We want to make it easy for anyone to understand your code, so we have a single set of guidelines for everyone writing C++ on any platform.

It is worth reiterating a few of the guidelines that you might forget if you are used to the prevalent Windows style:
\begin{itemize}
    \item Do not use Hungarian notation (for example, naming an integer \mintinline[breakanywhere,bgcolor=code_bg_pro]{C++}{iNum}). Use the Google naming conventions, including the \mintinline[breakanywhere,bgcolor=code_bg_pro]{C++}{.cc} extension for source files.
    \item Windows defines many of its own synonyms for primitive types, such as \mintinline[breakanywhere,bgcolor=code_bg_pro]{C++}{DWORD}, \mintinline[breakanywhere,bgcolor=code_bg_pro]{C++}{HANDLE}, etc. It is perfectly acceptable, and encouraged, that you use these types when calling Windows API functions. Even so, keep as close as you can to the underlying C++ types. For example, use \mintinline[breakanywhere,bgcolor=code_bg_pro]{C++}{const TCHAR *} instead of \mintinline[breakanywhere,bgcolor=code_bg_pro]{C++}{LPCTSTR}.
    \item When compiling with Microsoft Visual C++, set the compiler to warning level 3 or higher, and treat all warnings as errors.
    \item Do not use \mintinline[breakanywhere,bgcolor=code_bg_pro]{C++}{#pragma once}; instead use the standard Google include guards. The path in the include guards should be relative to the top of your project tree.
    \item In fact, do not use any nonstandard extensions, like \mintinline[breakanywhere,bgcolor=code_bg_pro]{C++}{#pragma} and \mintinline[breakanywhere,bgcolor=code_bg_pro]{C++}{__declspec}, unless you absolutely must. Using \mintinline[breakanywhere,bgcolor=code_bg_pro]{C++}{__declspec(dllimport)} and \mintinline[breakanywhere,bgcolor=code_bg_pro]{C++}{__declspec(dllexport)} is allowed; however, you must use them through macros such as \mintinline[breakanywhere,bgcolor=code_bg_pro]{C++}{DLLIMPORT} and \mintinline[breakanywhere,bgcolor=code_bg_pro]{C++}{DLLEXPORT}, so that someone can easily disable the extensions if they share the code.
\end{itemize}
However, there are just a few rules that we occasionally need to break on Windows:
\begin{itemize}
    \item Normally we \hyperref[sec:inheritance]{strongly discourage the use of multiple implementation inheritance}; however, it is required when using COM and some ATL/WTL classes. You may use multiple implementation inheritance to implement COM or ATL/WTL classes and interfaces.
    \item Although you should not use exceptions in your own code, they are used extensively in the ATL and some STLs, including the one that comes with Visual C++. When using the ATL, you should define \mintinline[breakanywhere,bgcolor=code_bg_pro]{C++}{_ATL_NO_EXCEPTIONS} to disable exceptions. You should investigate whether you can also disable exceptions in your STL, but if not, it is OK to turn on exceptions in the compiler. (Note that this is only to get the STL to compile. You should still not write exception handling code yourself.)
    \item The usual way of working with precompiled headers is to include a header file at the top of each source file, typically with a name like \mintinline[breakanywhere,bgcolor=code_bg_pro]{C++}{StdAfx.h} or \mintinline[breakanywhere,bgcolor=code_bg_pro]{C++}{precompile.h}. To make your code easier to share with other projects, avoid including this file explicitly (except in \mintinline[breakanywhere,bgcolor=code_bg_pro]{C++}{precompile.cc}), and use the \mintinline[breakanywhere,bgcolor=code_bg_pro]{C++}{/FI} compiler option to include the file automatically.
    \item Resource headers, which are usually named \mintinline[breakanywhere,bgcolor=code_bg_pro]{C++}{resource.h} and contain only macros, do not need to conform to these style guidelines.
\end{itemize}